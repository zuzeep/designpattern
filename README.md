> 自娱自乐的设计模式实现
---
#### 设计模式分类
1. 创建者模式
    - 简单工厂模式
    - 工厂模式
    - 抽象工厂模式
    - 单例模式
    - 创建者模式
    - 原型模式
2. 结构模式
    - 外观模式
    - 适配器模式
    - 桥接模式
    - 装饰器模式
    - 组合模式
    - 享元模式
    - 代理模式
3. 行为模式
    - 职责链模式
    - 策略模式
    - 模板模式
    - 命令模式
    - 观察者模式
    - 访问者模式
    - 状态模式
    - 中介者模式
    - 迭代器模式
    - 解释器模式
    - 备忘录模式

---
#### 索引

|名称|英文名称|简单描述|适用场景|描述|原文描述|备注|
|:---|:-------|:-------|:-------|:---|:-------|:---|
|单例模式|singleton|某个类只能有一个实例，提供一个全局的访问点|对象|允许实例的数量是可变的|确保一个类只有一个实例，并提供一个全局访问点来访问该实例|
|工厂模式|factory|定义一个创建对象的接口，让子类决定实例化那个类|对象|
|抽象工厂模式|abstract factory|创建相关或依赖对象的家族，而无需明确指定具体类|对象|
|创建者模式|builder|封装一个复杂对象的构建过程，并可以按步骤构造<br>这些对象具有不同表现形式|对象|
|原型模式|prototype|通过复制现有的实例来创建新的实例|对象|

|名称|英文名称|简单描述|适用场景|描述|原文描述|备注|
|:---|:-------|:-------|:-------|:---|:-------|:---|
|适配器模式|adapter|让我们改变一个对象的接口|对象|
|桥接模式|bridge|让我们改变一个对象的实现|对象|
|组合模式|composite|让我们改变对象的结构和组成|对象<br>递归的树型结构，比如文件系统|
|装饰器模式|decorator|让我们改变职责而无需派生子类|对象|
|外观模式|facade|让我们改变一个子系统的接口|子系统
|享元模式|flyweight|让我们改变对象的存储开销|对象|
|代理模式|proxy|让我们改变如何访问一个对象以及改变对象的问题|对象<br>增强对象功能|

|名称|英文名称|简单描述|适用场景|描述|原文描述|备注|
|:---|:-------|:-------|:-------|:---|:-------|:---|
|访问者模式|visitor|在不改变数据结构的前提下，增加作用于一组对象元素的新功能|对象<br>支持符号化连接，提供非入侵式添加与类型相关的新功能|
|观察者模式|observer|对象间的一对多的依赖关系|对象|
|模版模式|template|定义一个算法结构，而将一些步骤延迟到子类实现|类<br>|
|职责链模式|chainofresponsibility|解除发送者和接受者之间的耦合，使得多个对象都有机会处理|对象<br>将用户和它的组关联|
|中介者模式|mediator|用一个中介对象来封装一系列的对象交互|对象|
|命令模式|command|将命令请求封装为一个对象，使得可以用不同的请求来进行参数化|对象|
|备忘录模式|memeto|在不破坏封装的前提下，保持对象的内部状态|对象|
|迭代器模式|iterator|一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构|对象|
|策略模式|strategy|定义一系列算法，把他们封装起来，并且使它们可以相互替换|对象|
|状态模式|state|允许一个对象在其对象内部状态改变时改变它的行为|对象|
|解释器模式|interperter|给定一个语言，定义它的文法的一种表示，并定义一个解释器|类|
---
#### 参考书籍
- 设计模式沉思录
- Design Patterns_Elements of Reusable Object-Oriented Software
- 研磨设计模式
